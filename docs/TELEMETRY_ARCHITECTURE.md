# Телеметрия и Актуализация Устройств (Device Telemetry & Hybrid Sync)

Этот документ описывает всю техническую архитектуру того, как приложение собирает техническую информацию об устройствах Работников (Workers) и позволяет Директорам понимать, в каком состоянии находится телефон их подчинённого.

## Проблематика

В классических веб-приложениях Backend ничего не знает о состоянии клиента, пока клиент сам не сделает запрос. Однако для бизнес-приложения `Moment` критически важно знать:

1. Заряжен ли у работника телефон (почему он не выходит на связь?).
2. Выдал ли он разрешение на GPS (сможем ли мы отследить его маршрут на карте?).
3. Включены ли у него Push-уведомления на уровне операционной системы, или он удалил PWA?

Так как iOS (Apple) жестко ограничивает фоновые процессы для PWA (отсутствует возможность "тихих" пингов без участия пользователя), мы разработали **Гибридную архитектуру синхронизации (Hybrid Device Sync)**.

---

## 1. Фоновая Синхронизация (Aggressive Lazy-Sync)

Этот метод призван постоянно "спамить" базу данных свежей информацией **каждый раз, когда работник как-либо контактирует с приложением**.

### Как это работает:

В корневом файле приложения `components/Providers.tsx` встроен скрытый компонент `<DeviceSyncObserver />`. Внутри него крутится React-хук `hooks/useDeviceSync.ts`.

### Когда срабатывает синхронизация:

- **On Mount**: Когда работник открывает PWA (например, запускает приложение утром).
- **On Visibility Change**: Когда работник возвращается в приложение из спящего режима, из другой вкладки или после разблокировки экрана (`document.addEventListener('visibilitychange')`).

_Запрос дебаунсирован (throttled) на 2 секунды, чтобы не генерировать десятки запросов при быстром переключении окон._

### Что именно считывается у работника:

Скрипт использует нативные API браузера (`navigator`):

1. **Геопозиция (GPS):** `navigator.permissions.query({ name: 'geolocation' })`. Проверяет, выдано ли разрешение (Granted/Denied). Само местоположение _не запрашивается_ — считывается только статус разрешения!
2. **Батарея (Battery API):** `navigator.getBattery()`. Читает точный уровень заряда `level` (например, 87%) и статус `charging` (на зарядке лодка или нет). _Внимание: Настройки приватности iOS/Safari могут блокировать Battery API, в таком случае поле остается пустым._
3. **ОС и Браузер:** Парсится `navigator.userAgent`, чтобы определить устройство (например, `iOS 17.4` или `Android 14`).
4. **Push-подписка:** Сверяется статус подписки из хука `usePushNotifications`.

Все эти данные пакуются в JSON и отправляются POST-запросом на `api/staff/sync-device`.
Маршрут обновляет таблицу `users`, записывая данные в поля:
`pwaVersion`, `osVersion`, `batteryLevel`, `batteryStatus`, `geolocationEnabled`, `pushNotificationsEnabled`, а также принудительно обновляет дату `lastLoginAt = NOW()`.

---

## 2. Активная Проверка (Active Push Ping)

Фоновая синхронизация решает проблему с GPS и Батареей, но не решает одну важную проблему: **Что если Работник вчера удалил PWA с телефона, а в базе данных остался висеть его "активный" Token?** Backend будет думать, что телефон готов принимать уведомления, и отправлять их "в пустоту".

Для решения проблемы "Призрачных Токенов" (Ghost Tokens) внедрена кнопка **Ping Device**.

### Как это работает:

1. Директор заходит на страницу "Команда" (`app/[lang]/staff`) и открывает карточку Работника.
2. В секции "Device & Status -> Push Notifications" он видит кнопку **Ping Device**.
3. При нажатии, Frontend отправляет `POST /api/staff/verify-push`, передавая `targetUserID` работника.

### Логика Backend'а (`verify-push/route.ts`):

- Сервер находит в таблице `push_subscriptions` самый свежий токен (Endpoint) для этого работника.
- Вызывается `webpush.sendNotification()` с реальным `JSON`-пейлоадом (с тегом `"ping"`). Запрос летит на официальные сервера **Apple (APNs) или Google (FCM)**.
- Сервера Apple/Google пытаются связаться с устройством работника. У них есть 100% информация о том, живое ли устройство и установлено ли приложение на нём.

#### Результат Пинга:

Рассмотрим два сценария ответа от Apple/Google:

- **Success (201 Created):** Сервер Apple подтвердил принятие пакета. Наш Backend возвращает Директору зелёную галочку. Телефон работника жив и получает пуши.
- **Fail (410 Gone / 404 Not Found):** Это означает, что токен **отозван**. Это происходит, если работник удалил приложение с экрана "Домой", стер данные Safari или системно заблокировал Push-оповещения.
  - Наш Backend _перехватывает_ ошибку `410`.
  - Моментально удаляет этот Endpoint из таблицы `push_subscriptions` (`DELETE`).
  - Меняет статус `pushNotificationsEnabled = FALSE` в таблице `users` работника.
  - Сообщает Директору (выдавая красный Alert): `"Token was revoked by the device"`.

Таким образом, Директор может вручную "почистить" зависшие устройства и узнать реальную картину.

---

## 3. Таблица Базы Данных (Schema Updates)

Вся техническая информация хранится в таблице **`users`** (а не в `workers`!).
Это правильный архитектурный паттерн "Separation of Concerns". Таблица `users` отвечает за технический уровень (устройство, пароли, доступы, железо), а `workers` — за бизнес-уровень (Зарплата, имя, адрес объекта).

Добавленные поля в `users`:

- `lastLoginAt` (timestamp)
- `pwaVersion` (varchar)
- `osVersion` (varchar)
- `batteryLevel` (integer)
- `batteryStatus` (varchar)
- `geolocationEnabled` (boolean)
- `pushNotificationsEnabled` (boolean)

При запросе списка работников (`getWorkersByFirmaID`), система делает `LEFT JOIN` с таблицей `users` и собирает эту информацию воедино, возвращая на фронтенд полноценный объект с включенной телеметрией (Тип `Worker` в `types/scheduling.ts`).
