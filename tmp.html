What are the types of incubators?
Mar 11
SH1700_2015_Open_Side_1024x1024.jpeg
Setter
For the first 15 days of the eggs incubation period eggs must be placed in the setter, where they are turned every hour by the incubator. After the setting period eggs are physically moved to the hatcher, where they will hatch on the 17/18 day.

ProChick_180_Combo_Incubator_Hatcher_4_1024x1024.jpeg
Hatcher
The hatcher is the part of the incubator where the eggs lay still for the last 3 days the incubation cycle. Generally the humidity and airflow is slightly higher at this part of the incubator due to the fact that eggs require a higher humidity towards the hatching phase. The hatcher creates a stable environment for the eggs to hatch in. No turning of the eggs happens during this phase. The chick inside the eggs aligns itself so that it can peck its way out of the shell.

combination-incubator.jpg
Combination
A combo incubator is an incubator that combines both the setting and hatching phase. Design in which the setter and hatcher are combined into one device. Combo units work well when incubating and hatching smaller quantities of eggs. At a certain production level it becomes better to make use of separate setters and hatchers.



Incubating Quail Eggs
Mar 7

Quail eggs are a popular choice for both hobbyists and serious breeders due to their quick maturation and high productivity. Incubating quail eggs requires careful attention to environmental conditions and proper handling to ensure a successful hatch. This article outlines the key steps and considerations for incubating quail eggs effectively.

Selecting the Eggs
Before incubating, choose healthy, fertile eggs. Look for eggs that are clean, free of cracks, and have a uniform color. It's generally recommended to gather eggs no more than 7 days before incubation to maximize hatchability. Store the eggs in a cool, humid environment and keep them pointed end down.

Preparing the Incubator
A reliable incubator is essential for successful quail egg incubation. You can choose between still-air incubators and forced-air incubators. Forced-air incubators are generally more effective due to better temperature consistency.

Temperature and Humidity
The ideal temperature for incubating quail eggs is approximately 99.5°F (37.5°C). For still-air incubators, consider lowering the temperature slightly as eggs tend to be warmer in the upper part of the incubator.

Humidity levels are also crucial during the incubation process. Maintain humidity at around 45-50% for the first 14 days. During the final three days before hatching, increase the humidity to 65-70% to ensure proper development and easy hatching.

Turning the Eggs
Egg turning is vital for proper embryo development. In nature, quail eggs are turned by the parent birds, which helps prevent the embryo from sticking to the shell. If using a manual incubator, turn the eggs at least three times a day. Automatic turners make this process easier and more consistent.

Incubation Timeline
Quail eggs typically take about 17 to 18 days to hatch. It is important to monitor temperature and humidity closely throughout this period. On day 14, stop turning the eggs and increase humidity in preparation for hatching.

Recognizing Hatching Signs
As the hatch date approaches, you may observe signs of impending hatching. The eggs may begin to rock slightly, and tiny cracks may appear on the surface of the shells. It is essential to avoid opening the incubator during this time, as it can disturb humidity levels and lead to an unsuccessful hatch.

Post-Hatching Care
Once the quail chicks start hatching, allow them to stay in the incubator for several hours to dry and strengthen. Transfer them to a brooder after they have dried completely, typically within 24 hours.

Maintain warmth in the brooder environment with a heat lamp or heating pad, keeping the temperature around 95°F (35°C) for the first week. Gradually decrease the temperature by 5°F each week until reaching ambient room temperature.

Conclusion
Incubating quail eggs is a rewarding experience that requires attention to detail and an understanding of the necessary conditions for success. By following these guidelines, you'll be well on your way to hatching healthy quail chicks. With careful management, the process can lead to a fruitful outcome for your quail breeding endeavors.

Candling Guide
Aug 14
Candling Equipment and more
Often incubation is overlooked as an obscure process, mostly because the growth process is occurring 'behind closed doors' inside the chicken egg shell. When in reality, the quality of a quail is only as good as the egg from which it is hatched, for which proper breeding and diet.

Being able to follow the development of a chick from such an early stage as candling might help us understand the growth process and result in improvement of incubation results. Having an insight of viewing the internal contents of an egg is called the process of candling.

This name originates from the times where candles were used at a light source used in the earlier days of development of the incubation process. Candling an egg is as simple as, in a very dark room, holding up the blunt end of a chicken egg up to a strong LED candling torch allow the light to penetrate the shell and illuminate the inside of an egg.

When is it best to candle?
Make notes about your incubation and candling observations so that you will be able to remember what to do next time.

Of great importance in candling is the experience factor. Don’t worry too much if you don’t get all of it the first time, repetition, comparing and readjusting is key to getting the most out of this process.

View fullsize
candle-egg.jpg
After a little while, you will see the chicken eggs that are different and be able to tell a good one from a dud.

The first time is prior to setting the chicken eggs. This enables the observation of the freshness of the chicken eggs, which relates to storage conditions. Remove eggs with faults.

The second time is 1/3 way through incubation. This will indicate the infertile or clear chicken eggs, and will give the first humidity indication.

The third candling is after 2/3 through incubation. This will give a good idea of the continued development, and the critical moisture indicator. This is the last chance for humidity adjustment.

The fourth time is at the transfer to hatcher (3 days before hatch for chicken eggs). For other species, candle about three days before due hatch date. This candle will indicate that the humidity has been correct and that all is well.

When candling, compare the air cell size to the image above. If the air cell is not tracking well, such as the air cell is too small then reduce humidity in incubator.

Dear reader, 

There is a quite personal story behind the creation of this app and I’m hoping that people who have faced similar inconveniences as I did along my way will be able to find their answer in QuailBreeder. 

In the far 2012, due to some unpredictable circumstances, after years of career growth in Kyiv, I had to leave the capital and find a new home for me and my family in the rural areas. This came with a load of advantages, but for me as a city dweller was something new and different. 

I decided to try out quail breeding, having organised a farm, the aim of which was to produce quail meat. Not huge at the begging, situated solely in my backyard. It took 2 years for me to adjust the process of production and bring the general efficiency indicator to 50 kg of meat per week. Thereafter the game was on and i laid the eggs every week, which was quite a lot to remember, considering that i had to keep in mind the progression of 14-15 batches with over 3000 birds, i had to write it all down.The cycle of production was 60 days + 17 incubation. 

By education I am a programmer, so writing it all down on paper wasn’t something I was used to. Therefore, the most convenient option for that day was to write an application for a PC, which I did. I would input data on laying the eggs and other according information. I was truly satisfied with everything except the lack of mobility, so it hasn’t freed me from having to walk around with bits of paper. At the end of the working day i had to sit down and put all the data in about the following day. 

Unfortunately, soon after, I had to close the farm and get back to the computer due to a back injury, having to figure out a new way of making money for living. 

This has bought me some time to develop an app, with the functionality improved massively by an ability to fixate nuances like viability in the quail coop, info about transportation, etc. , and most importantly, it works flawlessly on mobile devices. 

So if you are a farmer producing quail meat, QuailBreeder presents to you all the functionality that you’ve been looking for and lacking this whole time. 


Thank you for your attention, 

Serhii Karavansky 

Frequently Asked Questions
How to get started?
To get started, you need to fill out the three main catalogs of the equipment you are using.

The first is a catalog of incubators, which provides for the use of three types (Setter, Hatcher and Combination),as well as the number of trays for each incubator and their egg capacity.

The second is a catalog of brooders, where it is required to specify the maximum possible number of chicks for each brooder.

And the last directory contains information about locations and cages. Locations are groups of cages for a specific task. For example: for keeping parent stock, for egg production or for meat production.


How to start using the app
Incubation
To get started, you have to fill out the three main catalogs of the equipment you are using.


To do this: select "Home" on the tab bar, then select "Settings" and configure the equipment in the application.

This application implements the accounting of main production operations of your quail farm.

The process consists of the following steps:

Incubation - laying eggs in incubators - provides for the use of an unlimited number of equipment, 3 types of incubators are supported

Hatching and moving chicks into brooders for growing up

Brooding 

Feeding moving the grown bird around locations to the corresponding cages

Slaughter of the required poultry for subsequent sale

At each stage, registration of birds mortality is provided with the fixation of the place, date and time of the event

Implemented support for connecting external calendars (iCloud, Google Calendar) to generate records of necessary tasks.

A visual display of the load of the equipment used (incubators, brooders, cages) makes it easy to understand how effectively it is being used and plan the necessary actions for the farmer to expand his business



<svg
  width="256"
  height="256"
  viewBox="0 0 256 256"
  fill="none"
  xmlns="http://www.w3.org/2000/svg"
>

  <defs>
    <!-- Градиент пина -->
    <linearGradient id="pinGradient" x1="0" y1="0" x2="1" y2="1">
      <stop offset="0%" stop-color="#1E90FF"/>
      <stop offset="100%" stop-color="#FF8C1A"/>
    </linearGradient>

    <!-- Внутренний круг -->
    <radialGradient id="innerCircle" cx="50%" cy="40%" r="60%">
      <stop offset="0%" stop-color="#2AA7FF"/>
      <stop offset="100%" stop-color="#0B3C74"/>
    </radialGradient>

    <!-- Увеличенная тень -->
    <radialGradient id="shadowGradient" cx="50%" cy="50%" r="50%">
      <stop offset="0%" stop-color="#000" stop-opacity="0.35"/>
      <stop offset="60%" stop-color="#000" stop-opacity="0.15"/>
      <stop offset="100%" stop-color="#000" stop-opacity="0"/>
    </radialGradient>
  </defs>

  <!-- Большая тень -->
  <ellipse
    cx="128"
    cy="214"
    rx="62"
    ry="16"
    fill="url(#shadowGradient)"
  />

  <!-- Волны активности -->
  <path
    d="M40 132 C72 94, 114 94, 146 132"
    stroke="#1E90FF"
    stroke-width="10"
    stroke-linecap="round"
    opacity="0.4"
  />
  <path
    d="M110 132 C142 94, 184 94, 216 132"
    stroke="#FF8C1A"
    stroke-width="10"
    stroke-linecap="round"
    opacity="0.4"
  />

  <!-- Пин -->
  <path
    d="M128 28
       C88 28, 64 58, 64 96
       C64 148, 128 216, 128 216
       C128 216, 192 148, 192 96
       C192 58, 168 28, 128 28Z"
    fill="url(#pinGradient)"
  />

  <!-- Внутренний круг -->
  <circle
    cx="128"
    cy="96"
    r="38"
    fill="url(#innerCircle)"
  />

  <!-- Галочка -->
  <path
    d="M110 96 L124 110 L150 82"
    stroke="white"
    stroke-width="10"
    stroke-linecap="round"
    stroke-linejoin="round"
    fill="none"
  />

</svg>


'use client'

import { useState, useRef, useEffect, useMemo } from 'react'
import { Card, Chip, ScrollShadow, Button } from '@heroui/react'
import { Calendar as CalendarIcon, ChevronLeft, ChevronRight } from 'lucide-react'
import { useScheduling } from '@/contexts/SchedulingContext'
import { isSameDate, getOnlyDate } from '@/lib/calendar-utils'
import AppointmentCard from './AppointmentCard'
import { useLanguage } from '@/hooks/useLanguage'

// Получить понедельник недели для указанной даты
const getMonday = (date: Date) => {
  const d = new Date(date)
  const day = d.getDay()
  const diff = d.getDate() - day + (day === 0 ? -6 : 1)
  return new Date(d.setDate(diff))
}

// Генерация массива дней для скроллинга (несколько недель)
const generateDaysForScroll = (centerDate: Date, weeksAround: number = 2) => {
  const days = []
  const totalDays = weeksAround * 7 * 2 // Количество дней до и после центра

  // Генерируем дни напрямую от centerDate
  for (let i = -totalDays; i <= totalDays; i++) {
    const date = new Date(centerDate)
    date.setDate(centerDate.getDate() + i)
    days.push(getOnlyDate(date))
  }

  return days
}

// Генерация массива дней на основе диапазона дат назначений
const generateDaysFromAppointments = (appointments: any[], today: Date) => {
  if (appointments.length === 0) {
    // Если нет назначений, генерируем стандартный диапазон ±6 месяцев
    return generateDaysForScroll(today, 26)
  }

  // Находим минимальную и максимальную даты из назначений
  let minDate = appointments[0].date
  let maxDate = appointments[0].date

  appointments.forEach(apt => {
    if (apt.date < minDate) minDate = apt.date
    if (apt.date > maxDate) maxDate = apt.date
  })

  // Добавляем буфер: 2 недели до минимальной даты и 2 недели после максимальной
  const startDate = new Date(minDate)
  startDate.setDate(startDate.getDate() - 14)

  const endDate = new Date(maxDate)
  endDate.setDate(endDate.getDate() + 14)

  // Также учитываем сегодняшнюю дату, чтобы она точно была в диапазоне
  const todayMinus2Weeks = new Date(today)
  todayMinus2Weeks.setDate(today.getDate() - 14)

  const todayPlus2Weeks = new Date(today)
  todayPlus2Weeks.setDate(today.getDate() + 14)

  const finalStartDate = startDate < todayMinus2Weeks ? startDate : todayMinus2Weeks
  const finalEndDate = endDate > todayPlus2Weeks ? endDate : todayPlus2Weeks

  // Генерируем все дни от startDate до endDate
  const days = []
  const currentDate = new Date(finalStartDate)

  while (currentDate <= finalEndDate) {
    days.push(getOnlyDate(new Date(currentDate)))
    currentDate.setDate(currentDate.getDate() + 1)
  }

  return days
}

type VisibleDayInfo = { element: HTMLElement; visiblePercentage: number; index: number }

// Функция для получения коротких названий дней недели на основе локали
const getWeekdayShortNames = (locale: string): string[] => {
  const baseDate = new Date(2024, 0, 1) // Понедельник, 1 января 2024
  const names: string[] = []

  for (let i = 0; i < 7; i++) {
    const date = new Date(baseDate)
    date.setDate(baseDate.getDate() + i)
    const shortName = date.toLocaleDateString(locale, { weekday: 'short' })
    names.push(shortName.charAt(0).toUpperCase() + shortName.slice(1))
  }

  return names
}

export default function WeeklyView() {
  const { appointments, setSelectedAppointment } = useScheduling()
  const lang = useLanguage()
  const today = getOnlyDate(new Date())

  // Генерируем короткие названия дней недели на основе текущей локали
  const WEEKDAY_NAMES = useMemo(() => getWeekdayShortNames(lang), [lang])

  const [currentDate, setCurrentDate] = useState(today)
  const [currentWeekStart, setCurrentWeekStart] = useState(getMonday(today))
  const scrollContainerRef = useRef<HTMLDivElement>(null)
  const headerScrollRef = useRef<HTMLDivElement>(null)
  const scrollAnimationFrameRef = useRef<number | undefined>(undefined)
  const isInitialMount = useRef(true)
  const isProgrammaticScroll = useRef(false) // Флаг для программного скролла
  const isProgrammaticHeaderScroll = useRef(false) // Флаг для программного скролла header

  // Генерируем массив дней на основе реальных дат назначений
  // Пересоздается только при изменении списка назначений
  const allDays = useMemo<Date[]>(() => {
    return generateDaysFromAppointments(appointments, today)
  }, [appointments, today]) // Пересоздается при изменении appointments или today

  // Храним allDays в ref для использования в обработчиках
  const allDaysRef = useRef<Date[]>(allDays)
  useEffect(() => {
    allDaysRef.current = allDays
  }, [allDays])

  // Генерируем текущую неделю для header (desktop и tablet)
  const currentWeekDays = useMemo(() => {
    const monday = getMonday(currentWeekStart)
    const days = []
    for (let i = 0; i < 7; i++) {
      const date = new Date(monday)
      date.setDate(monday.getDate() + i)
      days.push(getOnlyDate(date))
    }
    return days
  }, [currentWeekStart])

  // Генерируем дни для header скроллинга
  // Очень маленькие мобильные (<430px): текущая неделя + по 2 недели вперед и назад (5 недель) со скроллом
  // Средние мобильные (430-640px): только текущая неделя (7 дней) - статичный header с короткими названиями
  // Планшет и выше (≥640px): только текущая неделя (7 дней) - статичный header с полными названиями
  const [headerWeeksCount, setHeaderWeeksCount] = useState(0)

  useEffect(() => {
    const updateHeaderWeeksCount = () => {
      // Для очень маленьких мобильных (<430px) - 5 недель для скроллинга
      // Для средних мобильных и выше (≥430px) - только текущая неделя
      setHeaderWeeksCount(window.innerWidth < 430 ? 2 : 0)
    }

    updateHeaderWeeksCount()
    window.addEventListener('resize', updateHeaderWeeksCount)
    return () => window.removeEventListener('resize', updateHeaderWeeksCount)
  }, [])

  const allHeaderDays = useMemo(() => {
    const days = []
    const monday = getMonday(currentWeekStart)

    for (let week = -headerWeeksCount; week <= headerWeeksCount; week++) {
      for (let day = 0; day < 7; day++) {
        const date = new Date(monday)
        date.setDate(monday.getDate() + week * 7 + day)
        days.push(getOnlyDate(date))
      }
    }

    return days
  }, [currentWeekStart, headerWeeksCount])

  // Дни для отображения в основном контенте (DayView cards)
  // На планшете и desktop (≥768px) - только текущая неделя (7 дней)
  // На мобильном (<768px) - все дни для скроллинга
  const [isTabletOrDesktop, setIsTabletOrDesktop] = useState(false)

  useEffect(() => {
    const checkBreakpoint = () => {
      setIsTabletOrDesktop(window.innerWidth >= 768)
    }

    checkBreakpoint()
    window.addEventListener('resize', checkBreakpoint)
    return () => window.removeEventListener('resize', checkBreakpoint)
  }, [])

  const daysToDisplay = isTabletOrDesktop ? currentWeekDays : allDays

  // Переключение недели
  const handlePrevWeek = () => {
    // Сохраняем день недели текущего дня
    const newDate = new Date(currentDate)
    newDate.setDate(currentDate.getDate() - 7)
    const newDateOnly = getOnlyDate(newDate)

    setCurrentDate(newDateOnly)
    setCurrentWeekStart(getMonday(newDateOnly))
  }

  const handleNextWeek = () => {
    // Сохраняем день недели текущего дня
    const newDate = new Date(currentDate)
    newDate.setDate(currentDate.getDate() + 7)
    const newDateOnly = getOnlyDate(newDate)

    setCurrentDate(newDateOnly)
    setCurrentWeekStart(getMonday(newDateOnly))
  }

  // Scroll to current day when it changes
  useEffect(() => {
    const currentDayIndex = daysToDisplay.findIndex(day => isSameDate(day, currentDate))

    if (scrollContainerRef.current && currentDayIndex !== -1) {
      const container = scrollContainerRef.current
      const dayElements = container.querySelectorAll('[data-day-card]')

      if (dayElements[currentDayIndex]) {
        const dayElement = dayElements[currentDayIndex] as HTMLElement
        const containerWidth = container.clientWidth
        const dayWidth = dayElement.offsetWidth
        const scrollPosition = dayElement.offsetLeft - containerWidth / 2 + dayWidth / 2

        // Устанавливаем флаг программного скролла
        isProgrammaticScroll.current = true

        // Всегда используем instant для мгновенного перехода
        container.scrollTo({
          left: scrollPosition,
          behavior: 'instant',
        })

        // Сбрасываем флаг сразу после мгновенного скролла
        setTimeout(() => {
          isProgrammaticScroll.current = false
        }, 100)

        // После первого скролла переключаем флаг
        if (isInitialMount.current) {
          isInitialMount.current = false
        }
      }
    }
  }, [currentDate, daysToDisplay])

  // Scroll header to center current day (только для очень маленьких мобильных <430px)
  useEffect(() => {
    const headerContainer = headerScrollRef.current
    if (!headerContainer) return

    // Проверяем что это очень маленький мобильный (header scroll виден только <430px)
    if (window.innerWidth >= 430) return

    // Находим текущий день в header
    const currentDayElement = headerContainer.querySelector(
      `[data-header-day-index="${allHeaderDays.findIndex(day => isSameDate(day, currentDate))}"]`
    )

    if (currentDayElement) {
      const element = currentDayElement as HTMLElement
      const containerWidth = headerContainer.clientWidth
      const elementLeft = element.offsetLeft
      const elementWidth = element.offsetWidth

      // Центрируем текущий день
      const scrollPosition = elementLeft - containerWidth / 2 + elementWidth / 2

      // Устанавливаем флаг программного скролла header
      isProgrammaticHeaderScroll.current = true

      headerContainer.scrollTo({
        left: scrollPosition,
        behavior: 'instant',
      })

      // Сбрасываем флаг после завершения скролла
      setTimeout(() => {
        isProgrammaticHeaderScroll.current = false
      }, 500)
    }
  }, [currentDate, allHeaderDays])

  // Handle header scroll to update week range (только для очень маленьких мобильных <430px)
  useEffect(() => {
    const headerContainer = headerScrollRef.current
    if (!headerContainer) return

    // Отключаем для средних мобильных и выше (≥430px)
    if (window.innerWidth >= 430) return

    let scrollTimeout: NodeJS.Timeout | undefined
    let isProcessing = false
    let lastProcessedWeekStart: Date | null = null

    const handleHeaderScroll = () => {
      if (isProgrammaticHeaderScroll.current || isProcessing) {
        return
      }

      if (scrollTimeout) {
        clearTimeout(scrollTimeout)
      }

      scrollTimeout = setTimeout(() => {
        if (isProcessing) return

        const containerRect = headerContainer.getBoundingClientRect()
        const containerCenter = containerRect.left + containerRect.width / 2

        const dayElements = headerContainer.querySelectorAll('[data-header-day-index]')

        type DayInfo = { element: HTMLElement; distanceFromCenter: number; date: Date }
        let closestDay: DayInfo | null = null

        dayElements.forEach(dayEl => {
          const element = dayEl as HTMLElement
          const elementRect = element.getBoundingClientRect()
          const elementCenter = elementRect.left + elementRect.width / 2
          const distanceFromCenter = Math.abs(elementCenter - containerCenter)

          if (!closestDay || distanceFromCenter < closestDay.distanceFromCenter) {
            const dayIndexAttr = dayEl.getAttribute('data-header-day-index')
            const dayIndex = parseInt(dayIndexAttr || '0')
            const dayDate = allHeaderDays[dayIndex]
            if (dayDate) {
              closestDay = { element, distanceFromCenter, date: dayDate }
            }
          }
        })

        if (closestDay) {
          const day = closestDay as DayInfo
          const visibleWeekStart = getMonday(day.date)
          const currentMonday = getMonday(currentWeekStart)

          if (visibleWeekStart.getTime() !== currentMonday.getTime()) {
            if (
              !lastProcessedWeekStart ||
              lastProcessedWeekStart.getTime() !== visibleWeekStart.getTime()
            ) {
              isProcessing = true
              lastProcessedWeekStart = visibleWeekStart

              if (visibleWeekStart > currentMonday) {
                handleNextWeek()
              } else if (visibleWeekStart < currentMonday) {
                handlePrevWeek()
              }

              setTimeout(() => {
                isProcessing = false
                lastProcessedWeekStart = null
              }, 1000)
            }
          }
        }
      }, 200)
    }

    headerContainer.addEventListener('scroll', handleHeaderScroll)
    return () => {
      headerContainer.removeEventListener('scroll', handleHeaderScroll)
      if (scrollTimeout) {
        clearTimeout(scrollTimeout)
      }
    }
  }, [currentWeekStart, allHeaderDays])

  // Handle scroll to detect current visible day and week
  useEffect(() => {
    const container = scrollContainerRef.current
    if (!container) return

    const handleScroll = () => {
      // Игнорируем события скролла во время программного скролла
      if (isProgrammaticScroll.current) {
        return
      }

      // Отменяем предыдущий requestAnimationFrame если есть
      if (scrollAnimationFrameRef.current) {
        cancelAnimationFrame(scrollAnimationFrameRef.current)
      }

      // Используем requestAnimationFrame для моментального обновления
      scrollAnimationFrameRef.current = requestAnimationFrame(() => {
        const containerRect = container.getBoundingClientRect()
        const containerLeft = containerRect.left
        const containerRight = containerRect.right

        const dayElements = Array.from(
          container.querySelectorAll('[data-day-card]')
        ) as HTMLElement[]

        // Находим день с максимальной видимостью
        let maxVisibleDay: VisibleDayInfo | null = null

        dayElements.forEach(element => {
          const rect = element.getBoundingClientRect()
          const dayLeft = rect.left
          const dayRight = rect.right
          const dayWidth = rect.width

          // Вычисляем видимую часть дня
          const visibleLeft = Math.max(dayLeft, containerLeft)
          const visibleRight = Math.min(dayRight, containerRight)
          const visibleWidth = Math.max(0, visibleRight - visibleLeft)

          // Процент видимости дня
          const visiblePercentage = (visibleWidth / dayWidth) * 100

          const dayIndex = parseInt(element.getAttribute('data-day-index') || '0')

          // Ищем день с максимальной видимостью
          if (!maxVisibleDay || visiblePercentage > maxVisibleDay.visiblePercentage) {
            maxVisibleDay = { element, visiblePercentage, index: dayIndex }
          }
        })

        // Обновляем currentDate на день с максимальной видимостью
        if (maxVisibleDay) {
          const visibleDay = maxVisibleDay as VisibleDayInfo

          if (daysToDisplay && daysToDisplay[visibleDay.index]) {
            const newDate = daysToDisplay[visibleDay.index]

            if (!isSameDate(newDate, currentDate)) {
              setCurrentDate(newDate)
              // Update week if day is outside current week
              const newMonday = getMonday(newDate)
              if (!isSameDate(newMonday, currentWeekStart)) {
                setCurrentWeekStart(newMonday)
              }
            }
          }
        }
      })
    }

    container.addEventListener('scroll', handleScroll)
    return () => {
      container.removeEventListener('scroll', handleScroll)
      if (scrollAnimationFrameRef.current) {
        cancelAnimationFrame(scrollAnimationFrameRef.current)
      }
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [currentDate, currentWeekStart, daysToDisplay])

  const handleAppointmentClick = (appointmentId: string) => {
    const appointment = appointments.find(apt => apt.id === appointmentId)
    if (appointment) {
      setSelectedAppointment(appointment)
    }
  }

  // Форматирование диапазона дат для заголовка
  const getWeekRangeString = () => {
    // Генерируем 7 дней текущей недели от понедельника
    const monday = getMonday(currentWeekStart)
    const weekDays = []
    for (let i = 0; i < 7; i++) {
      const day = new Date(monday)
      day.setDate(monday.getDate() + i)
      weekDays.push(getOnlyDate(day))
    }

    const firstDay = weekDays[0]
    const lastDay = weekDays[6]

    const firstDayNum = firstDay.getDate()
    const lastDayNum = lastDay.getDate()
    const firstMonth = firstDay.toLocaleDateString(lang, { month: 'long' })
    const lastMonth = lastDay.toLocaleDateString(lang, { month: 'long' })
    const firstYear = firstDay.getFullYear()
    const lastYear = lastDay.getFullYear()

    // Если месяцы и годы одинаковые
    if (firstMonth === lastMonth && firstYear === lastYear) {
      return `${firstDayNum} - ${lastDayNum} ${firstMonth} ${firstYear}`
    }
    // Если годы одинаковые, но разные месяцы
    else if (firstYear === lastYear) {
      const firstMonthShort = firstDay.toLocaleDateString(lang, { month: 'short' })
      return `${firstDayNum} ${firstMonthShort} - ${lastDayNum} ${lastMonth} ${firstYear}`
    }
    // Если разные годы
    else {
      const firstMonthShort = firstDay.toLocaleDateString(lang, { month: 'short' })
      const lastMonthShort = lastDay.toLocaleDateString(lang, { month: 'short' })
      return `${firstDayNum} ${firstMonthShort} ${firstYear} - ${lastDayNum} ${lastMonthShort} ${lastYear}`
    }
  }

  // Group appointments by date
  const appointmentsByDate = appointments.reduce(
    (acc, appointment) => {
      const dateKey = getOnlyDate(appointment.date).toISOString()
      if (!acc[dateKey]) {
        acc[dateKey] = []
      }
      acc[dateKey].push(appointment)
      return acc
    },
    {} as Record<string, typeof appointments>
  )

  return (
    <div className="w-full h-full flex flex-col overflow-hidden">
      {/* Header with current date */}
      <div className="shrink-0 bg-background border-b border-divider pb-3">
        <div className="flex items-center justify-between gap-2 px-2 sm:px-4 mb-3">
          <button
            onClick={handlePrevWeek}
            className="p-2 hover:bg-default-100 rounded-lg transition-colors shrink-0"
            aria-label="Previous week"
          >
            <ChevronLeft className="w-5 h-5" />
          </button>

          <div className="flex items-center gap-2">
            <CalendarIcon className="w-5 h-5 text-primary" />
            <h2 className="text-lg sm:text-xl font-bold">{getWeekRangeString()}</h2>
          </div>

          <button
            onClick={handleNextWeek}
            className="p-2 hover:bg-default-100 rounded-lg transition-colors shrink-0"
            aria-label="Next week"
          >
            <ChevronRight className="w-5 h-5" />
          </button>
        </div>

        {/* Week days header - Desktop version (≥1024px, static, full names) */}
        <div className="hidden lg:flex justify-center gap-2 px-2">
          {currentWeekDays.map((day, dayIndex) => {
            const isToday = isSameDate(day, today)
            const isCurrentDay = isSameDate(day, currentDate)

            // Получаем полное название дня недели на основе текущей локали
            const weekdayLong = day.toLocaleDateString(lang, { weekday: 'long' })
            const capitalizedWeekdayLong =
              weekdayLong.charAt(0).toUpperCase() + weekdayLong.slice(1)

            // Определяем вариант кнопки
            const buttonVariant = isCurrentDay ? 'primary' : isToday ? 'danger' : 'tertiary'

            return (
              <div key={dayIndex} className="flex flex-col items-center gap-1 min-w-25">
                {/* Полное название дня */}
                <div className="text-xs text-default-500 text-center">{capitalizedWeekdayLong}</div>
                <Button
                  size="sm"
                  variant={buttonVariant}
                  onPress={() => setCurrentDate(day)}
                  className="min-w-0 w-10 h-10 p-0 rounded-full flex items-center justify-center"
                >
                  <div className="text-lg font-bold">{day.getDate()}</div>
                </Button>
              </div>
            )
          })}
        </div>

        {/* Week days header - Tablet version (640px-1023px, static, full names) */}
        <div className="hidden min-[640px]:flex lg:hidden justify-center gap-2 px-2">
          {currentWeekDays.map((day, dayIndex) => {
            const isToday = isSameDate(day, today)
            const isCurrentDay = isSameDate(day, currentDate)

            // Получаем полное название дня недели на основе текущей локали
            const weekdayLong = day.toLocaleDateString(lang, { weekday: 'long' })
            const capitalizedWeekdayLong =
              weekdayLong.charAt(0).toUpperCase() + weekdayLong.slice(1)

            const buttonVariant = isCurrentDay ? 'primary' : isToday ? 'danger' : 'tertiary'

            return (
              <div key={dayIndex} className="flex flex-col items-center gap-1 min-w-20">
                <div className="text-xs text-default-500 text-center">{capitalizedWeekdayLong}</div>
                <Button
                  size="sm"
                  variant={buttonVariant}
                  onPress={() => setCurrentDate(day)}
                  className="min-w-0 w-10 h-10 p-0 rounded-full flex items-center justify-center"
                >
                  <div className="text-lg font-bold">{day.getDate()}</div>
                </Button>
              </div>
            )
          })}
        </div>

        {/* Week days header - Medium Mobile version (430px-639px, static, short names) */}
        <div className="hidden min-[430px]:flex min-[640px]:hidden justify-center gap-1 min-[500px]:gap-2 px-2">
          {currentWeekDays.map((day, dayIndex) => {
            const isToday = isSameDate(day, today)
            const isCurrentDay = isSameDate(day, currentDate)

            const dayOfWeek = day.getDay()
            const weekdayIndex = dayOfWeek === 0 ? 6 : dayOfWeek - 1
            const weekdayShort = WEEKDAY_NAMES[weekdayIndex]

            const buttonVariant = isCurrentDay ? 'primary' : isToday ? 'danger' : 'tertiary'

            return (
              <div key={dayIndex} className="flex flex-col items-center gap-0.5 min-w-12 shrink-0">
                <div className="text-xs text-default-500 text-center">{weekdayShort}</div>
                <Button
                  size="sm"
                  variant={buttonVariant}
                  onPress={() => setCurrentDate(day)}
                  className="min-w-0 w-10 h-10 p-0 rounded-full flex items-center justify-center"
                >
                  <div className="text-lg font-bold">{day.getDate()}</div>
                </Button>
              </div>
            )
          })}
        </div>

        {/* Week days header - Small Mobile version (<430px, with scroll, short names) */}
        <ScrollShadow
          ref={headerScrollRef}
          orientation="horizontal"
          hideScrollBar
          className="min-[430px]:hidden px-2 snap-x snap-mandatory"
          size={0}
        >
          <div className="flex gap-2">
            {/* Группируем дни по неделям */}
            {Array.from({ length: Math.ceil(allHeaderDays.length / 7) }, (_, weekIndex) => {
              const weekStart = weekIndex * 7
              const weekDays = allHeaderDays.slice(weekStart, weekStart + 7)

              return (
                <div
                  key={weekIndex}
                  className="flex gap-1 min-[400px]:gap-2 snap-center shrink-0"
                  data-week-index={weekIndex}
                >
                  {weekDays.map((day, dayIndex) => {
                    const globalIndex = weekStart + dayIndex
                    const isToday = isSameDate(day, today)
                    const isCurrentDay = isSameDate(day, currentDate)

                    const dayOfWeek = day.getDay()
                    const weekdayIndex = dayOfWeek === 0 ? 6 : dayOfWeek - 1
                    const weekdayShort = WEEKDAY_NAMES[weekdayIndex]

                    const buttonVariant = isCurrentDay ? 'primary' : isToday ? 'danger' : 'tertiary'

                    return (
                      <div
                        key={globalIndex}
                        className="flex flex-col items-center gap-0.5 min-w-12 shrink-0"
                        data-header-day
                        data-header-day-index={globalIndex}
                      >
                        <div className="text-xs text-default-500 text-center">{weekdayShort}</div>
                        <Button
                          size="sm"
                          variant={buttonVariant}
                          onPress={() => setCurrentDate(day)}
                          className="min-w-0 w-10 h-10 p-0 rounded-full flex items-center justify-center"
                        >
                          <div className="text-lg font-bold">{day.getDate()}</div>
                        </Button>
                      </div>
                    )
                  })}
                </div>
              )
            })}
          </div>
        </ScrollShadow>
      </div>

      {/* Horizontal scrollable days (DayView cards) */}
      <ScrollShadow
        ref={scrollContainerRef}
        orientation="horizontal"
        hideScrollBar
        className="flex-1 min-h-0 snap-x snap-mandatory"
      >
        <div className="flex h-full gap-2 p-2">
          {daysToDisplay.map((day, index) => {
            const isToday = isSameDate(day, today)
            const isCurrentDay = isSameDate(day, currentDate)
            const dayAppointments = appointmentsByDate[day.toISOString()] || []

            // Sort appointments by start time
            const sortedAppointments = [...dayAppointments].sort((a, b) => {
              return a.startTime > b.startTime ? 1 : a.startTime < b.startTime ? -1 : 0
            })

            return (
              <div
                key={index}
                data-day-card
                data-day-index={index}
                onClick={() => setCurrentDate(day)}
                className={`
                  shrink-0 w-full h-full cursor-pointer snap-center
                  ${isCurrentDay ? 'ring-2 ring-primary' : ''}
                `}
              >
                <Card
                  className={`
                  h-full
                  ${isToday ? 'border-2 border-danger' : isCurrentDay ? 'border-2 border-primary' : ''}
                `}
                >
                  <Card.Content className="p-1 h-full flex flex-col">
                    {/* Day header */}
                    <div className="mb-3 pb-2 border-b border-divider">
                      <div className="text-sm text-default-500">
                        {day.toLocaleDateString(lang, { weekday: 'long' })}
                      </div>
                      <div
                        className={`
                        text-2xl font-bold
                        ${isToday ? 'text-danger' : isCurrentDay ? 'text-primary' : 'text-foreground'}
                      `}
                      >
                        {day.getDate()} {day.toLocaleDateString(lang, { month: 'long' })}
                      </div>
                    </div>

                    {/* Appointments list */}
                    <ScrollShadow className="flex-1 min-h-0" hideScrollBar={false}>
                      <div className="space-y-2">
                        {sortedAppointments.length === 0 ? (
                          <div className="text-center py-8 text-default-500">
                            <CalendarIcon className="mx-auto h-8 w-8 mb-2 opacity-50" />
                            <p className="text-sm">Нет назначений</p>
                          </div>
                        ) : (
                          sortedAppointments.map(appointment => (
                            <AppointmentCard
                              key={appointment.id}
                              appointment={appointment}
                              onClick={() => handleAppointmentClick(appointment.id)}
                              isDraggable={false}
                              forceDesktopView={true}
                            />
                          ))
                        )}
                      </div>
                    </ScrollShadow>
                  </Card.Content>
                </Card>
              </div>
            )
          })}
        </div>
      </ScrollShadow>
    </div>
  )
}
